# 스티커

[스티커](https://www.acmicpc.net/problem/9465)

소요시간: 1h 30m
해결여부: X
또 풀어볼 가치가 있는가: O

---

점화식을 찾아내기 위해 0번 index부터 조건에 맞게 최대값을 구하면서 나아감.

3번째 인덱스에서 최대값 구할 때, 다음과 같은 경우의 수를 발견함.

```C
// N은 입력받은 열의 길이.
memo[2][N];

sIndex = 0;
rIndex = 1; // sIndex와 겹치지 않기 위해 선언한 변수

memo[sIndex][i] = memo[rIndex][i-1];    // case 1
memo[sIndex][i] = max(memo[sIndex][i], memo[0][i-2]); // case 2
memo[sIndex][i] = max(memo[sIndex][i], memo[1][i-2]); // case 3

memo[sIndex][i] += arr[sIndex][i];
```

_case 1_
X X O
X O X

_case 2_
O X O
X X X

_case 3_
X X O
O X X

이케하면 예제는 맞는데.. 제출하면 틀린다.

최대값을 구할 수 있는 경우의수에서 뭔가 빠진 케이스가 있다는건데..

**해결해보자**

문제의 조건에 따르면, 1개 아이템을 선택하면 상하좌우 아이템을 선택하지 못한다.
위 경우의 수는 현재 아이템을 선택했을 경우의 케이스만 포함한다.

누락된 경우의수는 `memo[sIndex][i-1]`에서 나올 수 있다. 왜냐하면 현재 열의 스티커를 선택하지 않고 그 앞열에 최대크기의 값이 있을 수 있기 때문이다.

그럼 케이스는 4가지가 되는데.. 위 경우의수에서 겹치는 경우가 있다.

case 1과 2인데..

case1은 case2의 문제를 해결했기 때문이다. 작은 문제를 예시로 들어보자.

X X
X X

`memo[1][1]`은 arr[1][1] + memo[0][0]과 memo[1][0]의 최대값이기 때문이다.

그래서 경우의 수는

_case 1_
X X O
X O X

_case 2_
X X O
O X X

_case 3_
X O X
X X X

**다르게 해결하기**

D[i][j] : i번 열에서 j번째 스티커를 뜯거나 안뜯어서 얻는 최대점수

D[i][j]는 3가지 경우의 수

- D[i][0] 0번째꺼 뜯어서 얻는 최대합
- D[i][1] 1번째꺼 뜯어서 얻는 최대합
- D[i][2] 아무것도 안 뜯어서 얻는 최대합

## 나를 힘들게 한거

- 이 문장이 이해가 안갔다.

## 리빙 포인트

- 이걸 알아두면 담에 시간이 절약될 거 같다.
