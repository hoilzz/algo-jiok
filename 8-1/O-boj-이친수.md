# 이친수

[이친수](https://www.acmicpc.net/problem/2193)

소요시간: 20m
해결여부: O
또 풀어볼 가치가 있는가: X, DP로 풀기 쉬움.

---

**해결해보자**

이친수의 2가지 조건

1. 이친수는 0으로 시작하지 않는다.
2. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.

D[i]를 i자리 이친수 개수라고 할 때,

1이 두 번 연속 나타나지 않기 때문에, 2가지 경우의 수가 있다.

D[i][j] : i자리에서 j(0 or 1)로 끝날 때 이친수의 개수

D[i][0] : 마지막 숫자가 0이기 때문에 앞의 자리가 0 또는 1이 될 수 있다.
D[i][1] : 마지막 숫자가 1이기 때문에 _조건2_ 때문에 0만 될 수 있다.

```
D[i][0] = D[i-1][0] + D[i-1][1];
D[i][1] = D[i-1][0]
```

```C
int main(int argc, const char * argv[]) {
    int n;
    cin>>n;

    long long memo[n][2];

    memo[0][0] = 0;
    memo[0][1] = 1;

    for(int i = 1; i<n; i++) {
        memo[i][0] = memo[i-1][1] + memo[i-1][0];
        memo[i][1] = memo[i-1][0];
    }

    cout<<memo[n-1][0] + memo[n-1][1]<<endl;

    return 0;
}
```

## 나를 힘들게 한거

- 이 문장이 이해가 안갔다.

## 리빙 포인트

- 이걸 알아두면 담에 시간이 절약될 거 같다.
