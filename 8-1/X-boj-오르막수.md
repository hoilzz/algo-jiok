# 오르막수

[오르막 수](https://www.acmicpc.net/problem/11057)

소요시간: 1H
해결여부: X
또 풀어볼 가치가 있는가: O

수의 자리가 오름차순을 이루는 수를 말한다. 인접한 수가 같아도 오름차순이다.

예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.

수의 길이 N이 주어졌을 때 오르막수의 개수를 구해보자. (N은 1000이하의 자연수

---

2234, 3678와 같이 오름차순을 만족하는지 알기 위해.. 0부터 bottom-up으로 풀었다.

수의길이에 해당되는 모든 오름차순을 구해야하기 때문이다.

그래서 숫자 K가 있을 때..

D[K] = D[K.substr(0, k.length - 1)] && K[K.length - 2] < K[K.length -1] 일 경우 1, 아니면 0

위와 같이 코드를 작성했다.

하지만 길이가 1000의 자리까지 있을 수 있다. 위와 같이 하면 메모리 초과가 발생한다.

---

그렇다면 2차원 배열을 통해 뭔가 쪼개야 할 거 같다..

**해결해보자**

오름차순이라는 특성은 각 숫자가 바로 앞의 숫자보다 크면 된다.

위 특성을 이용하여, 모든 숫자의 오름 차순 여부를 구할 필요가 없다.

1의 자리부터 N의 자리까지, 마지막 숫자가 0~9일 경우를 bottom up으로 구하면된다.

```
D[N][K] += D[N-1][L] (L은 0~K까지)
```

위와 같이 하면 처음 겪은 문제 2가지, 공간복잡도와 모든 숫자의 오름 차순 여부 구하기를 해결할 수 있다.

```C
int n;
    cin>>n;

    int memo[n][10];

    fill_n(memo[0], 10, 1);

    // bottom-up으로 자리수1부터 채워나가기
    for(int i = 1; i<n; i++) {
        for(int k = 0; k<10; k++) {
            memo[i][k] = 0;
            for(int l=0; l<=k; l++) {
                memo[i][k] += memo[i-1][l] % 10007;
            }
        }
    }

    int result = 0;

    for(int i = 0; i<10; i++) {
        result += memo[n-1][i]  % 10007;
    }

    cout<<result % 10007<<endl;
```

## 나를 힘들게 한거

- 이 문장이 이해가 안갔다.

## 리빙 포인트

- 이걸 알아두면 담에 시간이 절약될 거 같다.
