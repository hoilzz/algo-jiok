# 문제이름

[오르막 수](https://www.acmicpc.net/problem/11057)

소요시간: 2h
해결여부: X
또 풀어볼 가치가 있는가: O

2234/3678/11119는 오르막수다. 2232, 3676, 91111은 오르막수가 아니다.
(오르막 수는 0으로 시작할 수 있다.)

길이가 N인 오르막 개수를 구하자.(N은 0이 아닌 1000이하의 자연수다)

오르막수의 개념 자체가 바로 앞의 숫자보다 크면 되는 거라, 작은 문제를 통해 큰 문제를 해결할 수 있는 DP라 생각했다.

그래서 생각해낸 **점화식은**

D[N] = N의 수가 오르막수인지 아닌지(1/0)
D[N] = D[K] && K의 마지막 숫자 < N (K는 N의 마지막 숫자를 제외한 숫자다.(N=123, K=12) )

위와 같이 할 경우,

- 마지막 숫자를 떼내기 위해 string 변환 -> int 변환 과정
- 공간복잡도가 최대 10^10 까지 보장해야 하므로 **이렇게 풀면 안된다.**

**해결해보자**

공간복잡도 문제를 해결하기 위해서 점화식을 변경해야한다.

점화식을 바꿔야 공간복잡도가 줄어든다.

유효한 점화식이 될 수 있는 100, 101, 102.. 를 예로 들자

> 이런 유형의 문제를 다시 풀게 될 떄 이러한 방식을 어떻게 떠올릴지 모르겠다.
> 이 문제는 애초에 유효한 오르막수의 경우의 수만 계산하여 bottom-up으로 해결 가능하다.
> 길이가 i이고 마지막 숫자가 j인 오르막 개수 => D[i][j]
> D[i][j] += D[i-1][k] (0<=k<=j)

오르막수는 앞의 숫자들은 중요하지 않고 마지막 숫자보다 크면된다.
여기서 중요하지 않다는 뜻은 이미 작은 문제로 해결한 문제들이기 때문에 마지막 숫자와 오르막수가 될 수 있는 숫자들을 후보로 하여 경우의 수를 ㄱ후ㅏ면된다.

## 나를 힘들게 한거

- 사실 유효한 오르막수만으로 bottom-up으로 풀 수 있다는 것에 대해.. 어떻게 저런 방법을 떠올릴지가 문제다..

## 리빙 포인트

- 공간복잡도가 엄청 커지는 경우 점화식을 통해 개선하자.
- 점화식으로 1234, 156789 와 같은 숫자를, `[숫자의 길이][마지막 숫자]` 와 같이 표현할 수 있다는 것을 알아두자.
