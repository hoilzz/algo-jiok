# 11055 가장 긴 증가하는 수열

[가장 긴 증가하는 수열](https://www.acmicpc.net/problem/11055)

소요시간: 1H
해결여부: X
또 풀어볼 가치가 있는가: O

bottom up으로 풀면서 마지막 index에 도달시 가장 큰 수열의 합을 구하면 된다.

D[N] = N까지의 최대 수열의 합

D[N] = A[N] + D[K] > D[N](k=0..N)

- 이 때 A[K]는 D[N] 의 증가수열이어야 한다.
  - 이것은 A[N] > A[K] 의 조건을 만족하면 된다.
- 최대 합이므로, A[N]과 D[K](k=0..N)에 대해 크기를 비교하며 최대크기인 값을 저장한다.

```C
    cin>>n;

    int arr[n];
    int d[n];

    for(int i = 0; i<n; i++) {
        cin>>arr[i];
    }

    // 1부터 n까지 각 D[n]을 구하기
    // 각 D[N]은 0~n까지 수열 후보가 되는 요소에 대해 모두 검사
    for(int i = 0; i<n; i++) {
        d[i] = 1;

        for(int j = 0; j<i; j++) {
            if(arr[i] > arr[j] && d[i] < d[j] + 1) {
                d[i] = d[j] + 1;
            }
        }
    }

    int answer = d[0];

    for(int i = 1; i<n; i++) {
        answer = max(d[i], answer);
    }
```

**해결해보자**

## 나를 힘들게 한거

- DP 자체가 작은 문제를 해결하여 큰문제를 해결하는건데,
- 작은 문제들의 해결한 점화식을 생각하지 않고 문제가 커질 때마다 작은 문제들을 다시 해결하고 있었다.

- DP에 대한 선입견
- 작은 문제의 해결을 통해 큰 문제를 해결한다. 이 뜻을 마지막 큰 문제가 무조건 정답이라는 생각을 했다.
- 하지만 위와 같은 문제는 내가 선택한 숫자에 따라 수열의 구성이 달라진다.
- 즉, index가 끝으로 갈수록 **가장 큰** 수열을 보장하지 않는다.
- 그래서, 각 index별로 가장 큰 수열을 구한 후, 0~N까지 for-loop에서 가장 긴 증가하는 수열을 찾아야 한다.

- 그래서 문제를 못푼듯

## 리빙 포인트

- 경우의 수가 아닌 최소/최대값을 구하는 것은 작은 문제들의 결과와 현재 문제의 결과를 합쳐서 비교한다.
